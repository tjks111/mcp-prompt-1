{
  "id": "mcp-resources-integration",
  "name": "MCP Resources Integration Guide",
  "description": "A comprehensive guide to working with and integrating resources across multiple MCP servers",
  "content": "# MCP Resources Integration Guide\\n\\nYou are an expert on the Model Context Protocol (MCP) ecosystem, specializing in resource integration across multiple MCP servers. Your task is to assist with {{integration_task}} by explaining how to leverage the resources/list method and integrate multiple data sources.\\n\\n## Understanding MCP Resources\\n\\nResources in the MCP ecosystem are named data objects that can be referenced and accessed across different MCP servers. They enable:\\n\\n1. **Cross-server data access**: Retrieving and using data from multiple specialized servers\\n2. **Contextual enrichment**: Adding relevant information to prompt templates\\n3. **Dynamic content generation**: Creating outputs based on up-to-date information\\n4. **Workflow orchestration**: Coordinating complex operations involving multiple data sources\\n\\n## The `resources/list` Method\\n\\nThe `resources/list` method is a powerful capability that enables discovery and exploration of available contextual data sources. It can be used to:\\n\\n- **Discover available resources**: List all accessible data sources across connected MCP servers\\n- **Filter resources by type**: Find specific kinds of resources (files, database records, API results)\\n- **Explore metadata**: View descriptions, timestamps, and other metadata about available resources\\n- **Support dynamic workflows**: Enable applications to adapt based on available context\\n\\n### Basic Usage\\n\\n```\\n// Example: Listing all available resources\\n{\\n  \\\\\\\"method\\\\\\\": \\\\\\\"resources/list\\\\\\\",\\n  \\\\\\\"params\\\\\\\": {}\\n}\\n\\n// Example: Filtering resources by prefix\\n{\\n  \\\\\\\"method\\\\\\\": \\\\\\\"resources/list\\\\\\\",\\n  \\\\\\\"params\\\\\\\": {\\n    \\\\\\\"prefix\\\\\\\": \\\\\\\"github://\\\\\\\"\\n  }\\n}\\n```\\n\\n## Integrating Resources from Different MCP Servers\\n\\n### Available Resource Types by Server\\n\\n| Server Type | Resource Prefix | Example URI | Description |\\n|-------------|----------------|-------------|-------------|\\n| GitHub | github:// | github://owner/repo/path/to/file | Repository files and metadata |\\n| Filesystem | file:// | file:///path/to/local/file | Local file system access |\\n| PostgreSQL | postgres:// | postgres://database/table/record | Database records and query results |\\n| Memory | memory:// | memory://session/key | Stored session context |\\n| Web | https:// | https://api.example.com/data | Web content and API responses |\\n| {{custom_server}} | {{custom_prefix}} | {{custom_example}} | {{custom_description}} |\\n\\n### Resource Integration Patterns\\n\\n#### 1. Chain of Resources Pattern\\nConnect multiple resources sequentially, where the output of one resource operation becomes the input for the next:\\n\\n```\\n// Step 1: Retrieve configuration from GitHub\\nconst config = await getResource('github://org/repo/config.json');\\n\\n// Step 2: Use config to query database\\nconst queryResults = await getResource(`postgres://database/table?query=${config.queryParams}`);\\n\\n// Step 3: Process results and store in memory\\nawait setResource('memory://session/processed_data', processData(queryResults));\\n```\\n\\n#### 2. Aggregation Pattern\\nCombine data from multiple resources to create a comprehensive context:\\n\\n```\\n// Collect data from multiple sources\\nconst codebase = await getResource('github://org/repo/src');\\nconst documentation = await getResource('file:///local/docs');\\nconst issueTracking = await getResource('https://issues.example.com/api/project');\\n\\n// Combine into unified context\\nconst projectContext = {\\n  code: codebase,\\n  docs: documentation,\\n  issues: issueTracking\\n};\\n```\\n\\n#### 3. Template Enrichment Pattern\\nUse resources to populate template variables dynamically:\\n\\n```\\n// Retrieve template\\nconst template = await getResource('prompts://templates/analysis');\\n\\n// Gather contextual data\\nconst repoStats = await getResource('github://org/repo/stats');\\nconst performanceData = await getResource('postgres://metrics/performance');\\n\\n// Apply template with resource data\\nconst enrichedPrompt = applyTemplate(template, {\\n  project_metrics: repoStats,\\n  performance_insights: performanceData\\n});\\n```\\n\\n## Implementation Guidelines for {{integration_task}}\\n\\n### Step 1: Resource Discovery\\nFirst, use the resources/list method to discover what data sources are available:\\n\\n```javascript\\n// Example resources/list implementation\\nasync function discoverResources() {\\n  const resources = await callMCP({\\n    method: 'resources/list',\\n    params: {}\\n  });\\n  \\n  console.log('Available resources:', resources);\\n  return resources;\\n}\\n```\\n\\n### Step 2: Resource Access Patterns\\nImplement standardized patterns for accessing different resource types:\\n\\n```javascript\\n// Example resource access function\\nasync function getResource(uri) {\\n  const serverType = getServerTypeFromUri(uri);\\n  \\n  const response = await callMCP({\\n    server: serverType,\\n    method: 'resources/get',\\n    params: { uri }\\n  });\\n  \\n  return response.data;\\n}\\n```\\n\\n### Step 3: Resource Integration\\nCombine resources using the appropriate integration pattern for your use case:\\n\\n{{integration_code}}\\n\\n### Step 4: Error Handling and Fallbacks\\nImplement robust error handling for cases where resources may be unavailable:\\n\\n```javascript\\ntry {\\n  const resource = await getResource('github://org/repo/file.json');\\n  // Process resource\\n} catch (error) {\\n  console.error('Error accessing resource:', error);\\n  // Use fallback resource or strategy\\n  const fallbackResource = await getResource('file:///local/fallback.json');\\n}\\n```\\n\\n## Best Practices for Resource Integration\\n\\n1. **Cache appropriately**: Some resources may be expensive to fetch repeatedly\\n2. **Handle failures gracefully**: Use fallbacks when resources are unavailable\\n3. **Consider resource formats**: Different servers may return different data structures\\n4. **Manage dependencies**: Be mindful of resource dependencies and potential circular references\\n5. **Document resource usage**: Make resource URIs and usage patterns explicit\\n6. **Security awareness**: Consider access control implications when sharing resources\\n{{additional_practices}}\\n\\n## Implementation Examples for Common Scenarios\\n\\n### Example 1: Project Analysis Dashboard\\nCombine code repository statistics, issue tracking, and documentation:\\n\\n```javascript\\nasync function buildProjectDashboard() {\\n  // Discover available resources\\n  const resources = await discoverResources();\\n  \\n  // Check if required resources are available\\n  const hasGitHub = resources.some(r => r.startsWith('github://'));\\n  const hasIssues = resources.some(r => r.startsWith('https://issues.'));\\n  \\n  // Gather data from available sources\\n  const repoData = hasGitHub ? \\n    await getResource('github://org/project/stats') : \\n    { error: 'GitHub data unavailable' };\\n    \\n  const issueData = hasIssues ?\\n    await getResource('https://issues.example.com/api/project/stats') :\\n    { error: 'Issue tracker unavailable' };\\n    \\n  // Combine into unified dashboard data\\n  return {\\n    code_metrics: repoData,\\n    issue_metrics: issueData,\\n    timestamp: new Date().toISOString()\\n  };\\n}\\n```\\n\\n### Example 2: Dynamic Document Generation\\nGenerate documentation by combining templates with real-time data:\\n\\n```javascript\\nasync function generateDocumentation() {\\n  // Get document template\\n  const template = await getResource('prompts://templates/documentation');\\n  \\n  // Gather data from multiple sources\\n  const apiSchema = await getResource('file:///api/schema.json');\\n  const usageStats = await getResource('postgres://analytics/api_usage');\\n  const exampleCode = await getResource('github://org/examples/api');\\n  \\n  // Generate documentation\\n  return applyTemplate(template, {\\n    schema: apiSchema,\\n    usage: usageStats,\\n    examples: exampleCode\\n  });\\n}\\n```\\n\\n### Example 3: {{custom_example_name}}\\n{{custom_example_description}}\\n\\n```javascript\\n{{custom_example_code}}\\n```\\n\\n## Resources/List Method in Action\\n\\nThe resources/list method serves multiple important functions:\\n\\n1. **Discovery and Exploration**: Clients can discover what contextual resources are available\\n2. **Workflow Orchestration**: Automated workflows can determine which resources to use\\n3. **Enhanced UI/UX**: User interfaces can show available resources for selection\\n4. **Integration with External Services**: Bridge between clients and external data sources\\n\\nExample implementation of a resource explorer using resources/list:\\n\\n```javascript\\nasync function exploreResources(prefix = '') {\\n  const resources = await callMCP({\\n    method: 'resources/list',\\n    params: { prefix }\\n  });\\n  \\n  // Group resources by type\\n  const resourcesByType = resources.reduce((groups, uri) => {\\n    const type = uri.split('://')[0];\\n    if (!groups[type]) groups[type] = [];\\n    groups[type].push(uri);\\n    return groups;\\n  }, {});\\n  \\n  // Display available resources by type\\n  for (const [type, uris] of Object.entries(resourcesByType)) {\\n    console.log(`${type} resources (${uris.length}):`);\\n    uris.forEach(uri => console.log(`  - ${uri}`));\\n  }\\n  \\n  return resourcesByType;\\n}\\n```\\n\\n## Conclusion\\n\\nEffective integration of resources across MCP servers is a powerful pattern that enables complex workflows, rich contextual awareness, and dynamic content generation. By understanding the resources/list method and implementing appropriate integration patterns, you can leverage the full potential of the MCP ecosystem for {{integration_task}}.\\n\\nWhat specific aspect of MCP resource integration would you like to explore further?\\\",\\n  \\\"isTemplate\\\": true,\\n  \\\"variables\\\": [\\n    \\\"integration_task\\\",\\n    \\\"custom_server\\\",\\n    \\\"custom_prefix\\\",\\n    \\\"custom_example\\\",\\n    \\\"custom_description\\\",\\n    \\\"integration_code\\\",\\n    \\\"additional_practices\\\",\\n    \\\"custom_example_name\\\",\\n    \\\"custom_example_description\\\",\\n    \\\"custom_example_code\\\"\\n  ],\\n  \\\"tags\\\": [\\n    \\\"mcp\\\",\\n    \\\"resources\\\",\\n    \\\"integration\\\",\\n    \\\"advanced\\\",\\n    \\\"multi-server\\\",\\n    \\\"template\\\"\\n  ],\\n  \\\"createdAt\\\": \\\"2025-03-15T16:00:00.000Z\\\",\\n  \\\"updatedAt\\\": \\\"2025-03-15T16:00:00.000Z\\\",\\n  \\\"version\\\": 1,\\n  \\\"metadata\\\": {\\n    \\\"recommended_servers\\\": [\\n      \\\"github\\\",\\n      \\\"filesystem\\\",\\n      \\\"postgres\\\",\\n      \\\"memory\\\",\\n      \\\"prompts\\\"\\n    ],\\n    \\\"example_variables\\\": {\\n      \\\"integration_task\\\": \\\"building a comprehensive project analysis tool\\\",\\n      \\\"custom_server\\\": \\\"TimeSeries\\\",\\n      \\\"custom_prefix\\\": \\\"timeseries://\\\",\\n      \\\"custom_example\\\": \\\"timeseries://metrics/cpu-usage/7d\\\",\\n      \\\"custom_description\\\": \\\"Historical time-series data for metrics and monitoring\\\",\\n      \\\"integration_code\\\": \\\"async function integrateProjectAnalysis() {\\\\n  // Get repository information\\\\n  const repoInfo = await getResource('github://org/repo/info');\\\\n  \\\\n  // Fetch relevant code files based on repo structure\\\\n  const codeFiles = await Promise.all(\\\\n    repoInfo.main_modules.map(module => \\\\n      getResource(`github://org/repo/src/${module}`)\\\\n    )\\\\n  );\\\\n  \\\\n  // Get database schema information\\\\n  const dbSchema = await getResource('postgres://database/information_schema');\\\\n  \\\\n  // Combine everything into a unified context\\\\n  const projectContext = {\\\\n    repository: repoInfo,\\\\n    code_modules: codeFiles,\\\\n    database_structure: dbSchema,\\\\n    analysis_timestamp: new Date().toISOString()\\\\n  };\\\\n  \\\\n  // Store the combined context in memory for future reference\\\\n  await setResource('memory://session/project_context', projectContext);\\\\n  \\\\n  return projectContext;\\\\n}\\\",\\n      \\\"additional_practices\\\": \\\"7. **Version awareness**: Consider resource version compatibility\\\\n8. **Performance tracking**: Monitor resource access patterns and optimize frequent operations\\\\n9. **Scope limitation**: Only access resources directly relevant to the current task\\\\n10. **Progressive enhancement**: Design systems that work with minimal resources but enhance capabilities when more are available\\\",\\n      \\\"custom_example_name\\\": \\\"Cross-Server Data Validation\\\",\\n      \\\"custom_example_description\\\": \\\"Validate data consistency across different storage systems by comparing repositories, databases, and local files:\\\",\\n      \\\"custom_example_code\\\": \\\"async function validateDataConsistency() {\\\\n  // Get configuration schema from repository\\\\n  const configSchema = await getResource('github://org/repo/schema/config.json');\\\\n  \\\\n  // Get actual configurations from database\\\\n  const dbConfigs = await getResource('postgres://app/configurations');\\\\n  \\\\n  // Get local configuration files\\\\n  const localConfigs = await getResource('file:///app/config/');\\\\n  \\\\n  // Compare configurations across systems\\\\n  const validationResults = {\\\\n    schema_valid: validateAgainstSchema(dbConfigs, configSchema),\\\\n    db_local_match: compareConfigurations(dbConfigs, localConfigs),\\\\n    mismatches: findMismatches(dbConfigs, localConfigs, configSchema)\\\\n  };\\\\n  \\\\n  // Store validation results in memory\\\\n  await setResource('memory://validation/config_results', validationResults);\\\\n  \\\\n  return validationResults;\\\\n}"
}