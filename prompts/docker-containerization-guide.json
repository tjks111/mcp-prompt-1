{
  "id": "docker-containerization-guide",
  "name": "Docker Containerization Guide",
  "description": "A template for setting up Docker containers for Node.js applications with best practices for multi-stage builds, security, and configuration",
  "content": "# Docker Containerization Guide for {{project_name}}\n\n## Overview\n\nThis guide outlines best practices for containerizing {{project_type}} applications using Docker, focusing on performance, security, and maintainability.\n\n## Dockerfile Best Practices\n\n### Multi-Stage Build Configuration\n\n```dockerfile\n# Build stage\nFROM node:{{node_version}}-alpine AS build\n\nWORKDIR /app\n\n# Set build-specific environment variables\nENV NODE_ENV=production \\\n    DOCKER_BUILD=true\n\n# Copy package files first for better layer caching\nCOPY package*.json ./\n\n# Install dependencies with appropriate locking\nRUN {{package_manager_install_command}}\n\n# Copy source code\nCOPY . .\n\n# Build the application\nRUN npm run build\n\n# Verify build success\nRUN if [ ! -f \"./{{build_output_file}}\" ]; then \\\n      echo \"❌ Build verification failed\"; \\\n      exit 1; \\\n    else \\\n      echo \"✅ Build verification successful\"; \\\n    fi\n\n# Production stage\nFROM node:{{node_version}}-alpine\n\nWORKDIR /app\n\n# Set production environment variables\nENV NODE_ENV=production \\\n    {{additional_env_variables}}\n\n# Copy only necessary files from build stage\nCOPY --from=build /app/{{build_dir}} ./{{build_dir}}\nCOPY --from=build /app/package*.json ./\nCOPY --from=build /app/node_modules ./node_modules\n{{additional_copy_commands}}\n\n# Create a non-root user\nRUN adduser -D -h /home/{{service_user}} {{service_user}}\n\n# Create necessary directories with appropriate permissions\nRUN mkdir -p {{data_directories}} && \\\n    chown -R {{service_user}}:{{service_user}} {{data_directories}}\n\n# Set the user\nUSER {{service_user}}\n\n# Create volume for data persistence\nVOLUME [\"{{data_volume}}\"]  \n\n# Add image metadata\nLABEL org.opencontainers.image.authors=\"{{image_authors}}\"\nLABEL org.opencontainers.image.title=\"{{image_title}}\"\nLABEL org.opencontainers.image.description=\"{{image_description}}\"\nLABEL org.opencontainers.image.documentation=\"{{documentation_url}}\"\nLABEL org.opencontainers.image.vendor=\"{{vendor}}\"\nLABEL org.opencontainers.image.licenses=\"{{license}}\"\n\n# Expose ports\nEXPOSE {{exposed_ports}}\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=10s --retries=3 \\\n  CMD {{health_check_command}} || exit 1\n\n# Run the application\nCMD [\"{{run_command}}\", \"{{run_args}}\"]  \n```\n\n## Docker Compose Configuration\n\n### Basic Configuration\n\n```yaml\nname: {{project_name}}\n\nservices:\n  # Main application service\n  {{service_name}}:\n    image: {{image_name}}:{{image_tag}}\n    container_name: {{container_name}}\n    environment:\n      - NODE_ENV=production\n      {{environment_variables}}\n    volumes:\n      - {{service_data_volume}}:{{container_data_path}}\n    ports:\n      - \"{{host_port}}:{{container_port}}\"\n    healthcheck:\n      test: [\"CMD\", {{healthcheck_command}}]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 5s\n    restart: unless-stopped\n\nvolumes:\n  {{service_data_volume}}:\n    name: {{volume_name}}\n```\n\n### Extended Configuration with Database\n\n```yaml\nname: {{project_name}}\n\nservices:\n  # Database service\n  {{database_service}}:\n    image: {{database_image}}:{{database_version}}\n    container_name: {{database_container_name}}\n    environment:\n      {{database_environment_variables}}\n    ports:\n      - \"{{database_host_port}}:{{database_container_port}}\"\n    volumes:\n      - {{database_data_volume}}:/{{database_data_path}}\n    healthcheck:\n      test: {{database_healthcheck_command}}\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    restart: unless-stopped\n\n  # Main application service\n  {{service_name}}:\n    image: {{image_name}}:{{image_tag}}\n    container_name: {{container_name}}\n    depends_on:\n      {{database_service}}:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=production\n      - {{database_connection_env_var}}=\n      {{environment_variables}}\n    volumes:\n      - {{service_data_volume}}:{{container_data_path}}\n    ports:\n      - \"{{host_port}}:{{container_port}}\"\n    healthcheck:\n      test: [\"CMD\", {{healthcheck_command}}]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 5s\n    restart: unless-stopped\n\nvolumes:\n  {{database_data_volume}}:\n    name: {{database_volume_name}}\n  {{service_data_volume}}:\n    name: {{volume_name}}\n```\n\n## Container Security Best Practices\n\n1. **Use Specific Version Tags**: Always specify exact versions for base images (e.g., `node:20.5.1-alpine` instead of `node:latest`)\n\n2. **Run as Non-Root User**: Create and use a dedicated non-root user for running the application\n\n3. **Minimize Container Privileges**: Apply the principle of least privilege\n\n4. **Secure Secrets Management**: Use environment variables, secret management tools, or Docker secrets for sensitive information\n\n5. **Image Scanning**: Regularly scan images for vulnerabilities\n\n6. **Multi-Stage Builds**: Use multi-stage builds to reduce attack surface\n\n7. **Distroless or Alpine Images**: Use minimal base images\n\n8. **Health Checks**: Implement health checks for monitoring container status\n\n## Containerized Testing\n\n### Test-Specific Dockerfile\n\n```dockerfile\nFROM node:{{node_version}}-alpine\n\nWORKDIR /test\n\n# Install test dependencies\nRUN {{test_dependencies_install}}\n\n# Set environment variables for testing\nENV NODE_ENV=test \\\n    {{test_environment_variables}}\n\n# Create test directories\nRUN mkdir -p {{test_directories}}\n\n# Add healthcheck\nHEALTHCHECK --interval=30s --timeout=10s --retries=3 --start-period=5s \\\n  CMD {{test_healthcheck_command}} || exit 1\n\n# Test command\nCMD [\"{{test_command}}\", \"{{test_args}}\"]  \n```\n\n### Test Docker Compose\n\n```yaml\nname: {{project_name}}-test\n\nservices:\n  # Test database\n  {{test_database_service}}:\n    image: {{database_image}}:{{database_version}}\n    container_name: {{test_database_container}}\n    environment:\n      {{test_database_environment}}\n    healthcheck:\n      test: {{database_healthcheck_command}}\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    networks:\n      - test-network\n\n  # Test application\n  {{test_service_name}}:\n    build:\n      context: .\n      dockerfile: Dockerfile.test\n    container_name: {{test_container_name}}\n    depends_on:\n      {{test_database_service}}:\n        condition: service_healthy\n    environment:\n      - NODE_ENV=test\n      - {{database_connection_env_var}}=\n      {{test_environment_variables}}\n    volumes:\n      - ./tests:/test/tests\n    networks:\n      - test-network\n\nnetworks:\n  test-network:\n    name: {{test_network_name}}\n```\n\n## Production Deployment Considerations\n\n1. **Resource Limits**: Set appropriate CPU and memory limits for containers\n\n2. **Logging Configuration**: Configure appropriate logging drivers and rotation policies\n\n3. **Container Orchestration**: Consider using Kubernetes, Docker Swarm, or similar tools for production deployments\n\n4. **Backup Strategy**: Implement a strategy for backing up data volumes\n\n5. **Monitoring**: Set up appropriate monitoring and alerting for containers\n\n6. **Network Security**: Configure network policies and firewall rules for container communication\n\n7. **Scaling Strategy**: Plan for horizontal and vertical scaling as needed\n\n## Implementation Notes\n\n{{implementation_notes}}\n",
  "isTemplate": true,
  "variables": [
    "project_name",
    "project_type",
    "node_version",
    "package_manager_install_command",
    "build_output_file",
    "build_dir",
    "additional_env_variables",
    "additional_copy_commands",
    "service_user",
    "data_directories",
    "data_volume",
    "image_authors",
    "image_title",
    "image_description",
    "documentation_url",
    "vendor",
    "license",
    "exposed_ports",
    "health_check_command",
    "run_command",
    "run_args",
    "service_name",
    "image_name",
    "image_tag",
    "container_name",
    "environment_variables",
    "service_data_volume",
    "container_data_path",
    "host_port",
    "container_port",
    "healthcheck_command",
    "volume_name",
    "database_service",
    "database_image",
    "database_version",
    "database_container_name",
    "database_environment_variables",
    "database_host_port",
    "database_container_port",
    "database_data_volume",
    "database_data_path",
    "database_healthcheck_command",
    "database_connection_env_var",
    "database_volume_name",
    "test_dependencies_install",
    "test_environment_variables",
    "test_directories",
    "test_healthcheck_command",
    "test_command",
    "test_args",
    "test_database_service",
    "test_database_container",
    "test_database_environment",
    "test_service_name",
    "test_container_name",
    "test_network_name",
    "implementation_notes"
  ],
  "tags": [
    "development",
    "docker",
    "containerization",
    "devops",
    "deployment",
    "template"
  ],
  "category": "devops",
  "createdAt": "2024-08-08T16:00:00.000Z",
  "updatedAt": "2024-08-08T16:00:00.000Z",
  "version": 1
} 