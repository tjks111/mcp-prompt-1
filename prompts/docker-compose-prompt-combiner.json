{
  "id": "docker-compose-prompt-combiner",
  "name": "Docker Compose Prompt Combiner",
  "description": "A specialized prompt combiner for creating Docker Compose configurations that integrates service definitions, volumes, networks, and deployment patterns",
  "content": "/**\n * DockerComposePromptCombiner for {{project_name}}\n * \n * A specialized implementation of the PromptCombiner interface\n * focused on combining prompts for Docker Compose configuration and orchestration.\n */\n\nimport { PromptCombiner, CombinerContext, CombinedPromptResult, PromptSuggestion, CombinationValidationResult, WorkflowConfig, SavedWorkflow } from './prompt-combiner-interface';\nimport { PromptService } from '../services/prompt-service';\nimport { Prompt } from '../core/types';\n\n/**\n * Docker Compose specific context\n */\nexport interface DockerComposeContext extends CombinerContext {\n  /** Project environment (development, staging, production) */\n  environment: 'development' | 'staging' | 'production' | string;\n  \n  /** Services to include in the configuration */\n  services: {\n    name: string;\n    type: string;\n    image?: string;\n    ports?: string[];\n    volumes?: string[];\n    environment?: Record<string, string>;\n    dependencies?: string[];\n  }[];\n  \n  /** Networks to define */\n  networks?: {\n    name: string;\n    external?: boolean;\n    driver?: string;\n  }[];\n  \n  /** Volumes to define */\n  volumes?: {\n    name: string;\n    driver?: string;\n    external?: boolean;\n  }[];\n  \n  /** Docker Compose version */\n  composeVersion?: string;\n  \n  /** Orchestration platform */\n  platform?: 'docker' | 'kubernetes' | 'swarm';\n  \n  /** Resource constraints */\n  resources?: {\n    memoryLimits?: boolean;\n    cpuLimits?: boolean;\n  };\n  \n  /** Additional Docker-specific context */\n  {{additional_docker_context}}\n}\n\n/**\n * Specialized result for Docker Compose combinations\n */\nexport interface DockerComposeResult extends CombinedPromptResult {\n  /** Generated Docker Compose configuration */\n  composeConfiguration?: string;\n  \n  /** Individual service configurations */\n  serviceConfigurations?: Record<string, string>;\n  \n  /** Network configurations */\n  networkConfigurations?: string;\n  \n  /** Volume configurations */\n  volumeConfigurations?: string;\n  \n  /** Deployment commands */\n  deploymentCommands?: string;\n  \n  /** Generated Dockerfiles */\n  dockerfiles?: Record<string, string>;\n  \n  /** Additional Docker-specific results */\n  {{additional_docker_results}}\n}\n\n/**\n * Implementation of DockerComposePromptCombiner\n */\nexport class DockerComposePromptCombiner implements PromptCombiner {\n  constructor(private promptService: PromptService) {}\n  \n  /**\n   * Combines Docker Compose prompts\n   * @param promptIds Array of prompt IDs to combine\n   * @param context Optional Docker Compose context\n   * @returns Combined Docker Compose result\n   */\n  async combinePrompts(promptIds: string[], context?: DockerComposeContext): Promise<DockerComposeResult> {\n    // Implementation would include:\n    // 1. Validating the prompts are compatible for Docker Compose configurations\n    // 2. Organizing prompts into service, network, and volume sections\n    // 3. Resolving dependencies between services\n    // 4. Applying variables with Docker Compose knowledge\n    // 5. Generating a comprehensive deployment configuration\n    \n    // This is a template structure - in a real implementation, this would contain\n    // the actual logic for combining Docker Compose prompts\n    \n    // For now, we'll outline the structure of how the implementation would work\n    \n    // Step 1: Load and categorize all prompts\n    const prompts = await Promise.all(promptIds.map(id => this.promptService.getPrompt(id)));\n    \n    const servicePrompts = prompts.filter(p => p.tags?.includes('service'));\n    const networkPrompts = prompts.filter(p => p.tags?.includes('network'));\n    const volumePrompts = prompts.filter(p => p.tags?.includes('volume'));\n    const deploymentPrompts = prompts.filter(p => p.tags?.includes('deployment'));\n    \n    // Step 2: Apply variables to each prompt category\n    const variables = context?.variables || {};\n    \n    // Combine service configurations\n    const services = await this.combineServices(servicePrompts, context);\n    \n    // Combine network configurations\n    const networks = await this.combineNetworks(networkPrompts, context);\n    \n    // Combine volume configurations\n    const volumes = await this.combineVolumes(volumePrompts, context);\n    \n    // Combine deployment commands\n    const deployment = await this.combineDeployment(deploymentPrompts, context);\n    \n    // Step 3: Create combined Docker Compose content\n    const composeVersion = context?.composeVersion || '3.8';\n    const serviceName = variables.service_name || 'app';\n    \n    const composeConfiguration = `version: '${composeVersion}'\n\nservices:\n${services.content}\n\nnetworks:\n${networks.content}\n\nvolumes:\n${volumes.content}\n`;\n    \n    // Step 4: Return the comprehensive result\n    return {\n      content: `# Docker Compose Configuration for ${variables.project_name || 'Your Project'}\n\n## Docker Compose File\n\n\\`\\`\\`yaml\n${composeConfiguration}\n\\`\\`\\`\n\n## Deployment Commands\n\n${deployment.content}\n`,\n      components: [\n        ...services.components,\n        ...networks.components,\n        ...volumes.components,\n        ...deployment.components\n      ],\n      appliedVariables: variables,\n      composeConfiguration,\n      serviceConfigurations: this.extractServiceConfigurations(services.content),\n      networkConfigurations: networks.content,\n      volumeConfigurations: volumes.content,\n      deploymentCommands: deployment.content,\n      // Add suggestion for what to do next\n      nextSteps: [\n        { action: 'validate_compose', description: 'Validate the Docker Compose configuration using docker-compose config' },\n        { action: 'deploy_compose', description: 'Deploy services using docker-compose up -d' },\n        { action: 'monitor_services', description: 'Monitor service logs using docker-compose logs -f' },\n        { action: 'scale_services', description: 'Scale services as needed using docker-compose up -d --scale' }\n      ]\n    };\n  }\n  \n  /**\n   * Helper method to combine service prompts\n   * @param prompts Service prompts\n   * @param context Docker Compose context\n   * @returns Combined result for services\n   */\n  private async combineServices(prompts: Prompt[], context?: DockerComposeContext): Promise<CombinedPromptResult> {\n    // Implementation would combine service definitions\n    // For our template, we'll create a simplified implementation\n    let content = '';\n    const components: {id: string; name: string; contribution: string}[] = [];\n    const variables = context?.variables || {};\n    \n    // If no service prompts but we have services in context, create from context\n    if (prompts.length === 0 && context?.services?.length) {\n      content = this.generateServicesFromContext(context);\n      components.push({\n        id: 'generated-services',\n        name: 'Generated Services',\n        contribution: content\n      });\n    } else {\n      // Otherwise use the prompts\n      for (const prompt of prompts) {\n        const result = await this.promptService.applyTemplate(prompt.id, variables);\n        content += result.content + '\\n';\n        components.push({\n          id: prompt.id,\n          name: prompt.name,\n          contribution: result.content\n        });\n      }\n    }\n    \n    return {\n      content: content.trim(),\n      components,\n      appliedVariables: variables\n    };\n  }\n  \n  /**\n   * Generate service definitions from context\n   * @param context Docker Compose context\n   * @returns Generated service YAML\n   */\n  private generateServicesFromContext(context: DockerComposeContext): string {\n    let servicesYaml = '';\n    \n    for (const service of context.services) {\n      servicesYaml += `  ${service.name}:\\n`;\n      if (service.image) {\n        servicesYaml += `    image: ${service.image}\\n`;\n      } else {\n        servicesYaml += `    build: ./${service.name}\\n`;\n      }\n      \n      if (service.ports && service.ports.length) {\n        servicesYaml += '    ports:\\n';\n        for (const port of service.ports) {\n          servicesYaml += `      - \"${port}\"\\n`;\n        }\n      }\n      \n      if (service.environment && Object.keys(service.environment).length) {\n        servicesYaml += '    environment:\\n';\n        for (const [key, value] of Object.entries(service.environment)) {\n          servicesYaml += `      - ${key}=${value}\\n`;\n        }\n      }\n      \n      if (service.volumes && service.volumes.length) {\n        servicesYaml += '    volumes:\\n';\n        for (const volume of service.volumes) {\n          servicesYaml += `      - ${volume}\\n`;\n        }\n      }\n      \n      if (service.dependencies && service.dependencies.length) {\n        servicesYaml += '    depends_on:\\n';\n        for (const dep of service.dependencies) {\n          servicesYaml += `      - ${dep}\\n`;\n        }\n      }\n      \n      // Add resource constraints if specified\n      if (context.resources?.cpuLimits || context.resources?.memoryLimits) {\n        servicesYaml += '    deploy:\\n      resources:\\n        limits:\\n';\n        if (context.resources.cpuLimits) {\n          servicesYaml += '          cpus: \"1.0\"\\n';\n        }\n        if (context.resources.memoryLimits) {\n          servicesYaml += '          memory: 512M\\n';\n        }\n      }\n      \n      servicesYaml += '\\n';\n    }\n    \n    return servicesYaml;\n  }\n  \n  /**\n   * Helper method to combine network prompts\n   * @param prompts Network prompts\n   * @param context Docker Compose context\n   * @returns Combined result for networks\n   */\n  private async combineNetworks(prompts: Prompt[], context?: DockerComposeContext): Promise<CombinedPromptResult> {\n    // Implementation would combine network definitions\n    let content = '';\n    const components: {id: string; name: string; contribution: string}[] = [];\n    const variables = context?.variables || {};\n    \n    // If no network prompts but we have networks in context, create from context\n    if (prompts.length === 0 && context?.networks?.length) {\n      content = this.generateNetworksFromContext(context);\n      components.push({\n        id: 'generated-networks',\n        name: 'Generated Networks',\n        contribution: content\n      });\n    } else if (prompts.length === 0) {\n      // Default network if nothing provided\n      content = `  app-network:\\n    driver: bridge\\n`;\n      components.push({\n        id: 'default-network',\n        name: 'Default Network',\n        contribution: content\n      });\n    } else {\n      // Otherwise use the prompts\n      for (const prompt of prompts) {\n        const result = await this.promptService.applyTemplate(prompt.id, variables);\n        content += result.content + '\\n';\n        components.push({\n          id: prompt.id,\n          name: prompt.name,\n          contribution: result.content\n        });\n      }\n    }\n    \n    return {\n      content: content.trim(),\n      components,\n      appliedVariables: variables\n    };\n  }\n  \n  /**\n   * Generate network definitions from context\n   * @param context Docker Compose context\n   * @returns Generated network YAML\n   */\n  private generateNetworksFromContext(context: DockerComposeContext): string {\n    let networksYaml = '';\n    \n    for (const network of context.networks || []) {\n      networksYaml += `  ${network.name}:\\n`;\n      if (network.driver) {\n        networksYaml += `    driver: ${network.driver}\\n`;\n      }\n      if (network.external) {\n        networksYaml += `    external: true\\n`;\n      }\n      networksYaml += '\\n';\n    }\n    \n    return networksYaml;\n  }\n  \n  /**\n   * Helper method to combine volume prompts\n   * @param prompts Volume prompts\n   * @param context Docker Compose context\n   * @returns Combined result for volumes\n   */\n  private async combineVolumes(prompts: Prompt[], context?: DockerComposeContext): Promise<CombinedPromptResult> {\n    // Implementation would combine volume definitions\n    let content = '';\n    const components: {id: string; name: string; contribution: string}[] = [];\n    const variables = context?.variables || {};\n    \n    // If no volume prompts but we have volumes in context, create from context\n    if (prompts.length === 0 && context?.volumes?.length) {\n      content = this.generateVolumesFromContext(context);\n      components.push({\n        id: 'generated-volumes',\n        name: 'Generated Volumes',\n        contribution: content\n      });\n    } else if (prompts.length === 0) {\n      // Default volume if nothing provided\n      content = `  app-data:\\n`;\n      components.push({\n        id: 'default-volume',\n        name: 'Default Volume',\n        contribution: content\n      });\n    } else {\n      // Otherwise use the prompts\n      for (const prompt of prompts) {\n        const result = await this.promptService.applyTemplate(prompt.id, variables);\n        content += result.content + '\\n';\n        components.push({\n          id: prompt.id,\n          name: prompt.name,\n          contribution: result.content\n        });\n      }\n    }\n    \n    return {\n      content: content.trim(),\n      components,\n      appliedVariables: variables\n    };\n  }\n  \n  /**\n   * Generate volume definitions from context\n   * @param context Docker Compose context\n   * @returns Generated volume YAML\n   */\n  private generateVolumesFromContext(context: DockerComposeContext): string {\n    let volumesYaml = '';\n    \n    for (const volume of context.volumes || []) {\n      volumesYaml += `  ${volume.name}:\\n`;\n      if (volume.driver) {\n        volumesYaml += `    driver: ${volume.driver}\\n`;\n      }\n      if (volume.external) {\n        volumesYaml += `    external: true\\n`;\n      }\n      volumesYaml += '\\n';\n    }\n    \n    return volumesYaml;\n  }\n  \n  /**\n   * Helper method to combine deployment prompts\n   * @param prompts Deployment prompts\n   * @param context Docker Compose context\n   * @returns Combined result for deployment\n   */\n  private async combineDeployment(prompts: Prompt[], context?: DockerComposeContext): Promise<CombinedPromptResult> {\n    // Implementation would combine deployment commands\n    let content = '';\n    const components: {id: string; name: string; contribution: string}[] = [];\n    const variables = context?.variables || {};\n    \n    // If no deployment prompts, generate default commands\n    if (prompts.length === 0) {\n      const projectName = variables.project_name || 'myproject';\n      const env = context?.environment || 'development';\n      \n      content = `# Start all services\ndocker-compose -p ${projectName} -f docker-compose.${env}.yml up -d\n\n# View service logs\ndocker-compose -p ${projectName} -f docker-compose.${env}.yml logs -f\n\n# Scale specific services\ndocker-compose -p ${projectName} -f docker-compose.${env}.yml up -d --scale service_name=3\n\n# Stop all services\ndocker-compose -p ${projectName} -f docker-compose.${env}.yml down\n\n# Stop and remove volumes\ndocker-compose -p ${projectName} -f docker-compose.${env}.yml down -v`;\n      \n      components.push({\n        id: 'default-deployment',\n        name: 'Default Deployment Commands',\n        contribution: content\n      });\n    } else {\n      // Otherwise use the prompts\n      for (const prompt of prompts) {\n        const result = await this.promptService.applyTemplate(prompt.id, variables);\n        content += result.content + '\\n\\n';\n        components.push({\n          id: prompt.id,\n          name: prompt.name,\n          contribution: result.content\n        });\n      }\n    }\n    \n    return {\n      content: content.trim(),\n      components,\n      appliedVariables: variables\n    };\n  }\n  \n  /**\n   * Extract individual service configurations from combined YAML\n   * @param servicesYaml Combined services YAML\n   * @returns Object with service name keys and configuration values\n   */\n  private extractServiceConfigurations(servicesYaml: string): Record<string, string> {\n    const services: Record<string, string> = {};\n    const serviceBlocks = servicesYaml.split(/^\\s{2}[^\\s]+:/gm);\n    \n    // Skip the first empty block if it exists\n    const startIndex = serviceBlocks[0].trim() === '' ? 1 : 0;\n    \n    for (let i = startIndex; i < serviceBlocks.length; i++) {\n      const block = serviceBlocks[i];\n      const nameMatch = block.match(/^\\s*([^\\s:]+)\\s*$/m);\n      \n      if (nameMatch && nameMatch[1]) {\n        const serviceName = nameMatch[1];\n        services[serviceName] = block.trim();\n      }\n    }\n    \n    return services;\n  }\n  \n  /**\n   * Gets Docker Compose prompt suggestions\n   * @param category Optional category to filter by\n   * @param context Current Docker Compose context to inform suggestions\n   * @returns Array of prompt suggestions for Docker Compose configurations\n   */\n  async getPromptSuggestions(category?: string, context?: DockerComposeContext): Promise<PromptSuggestion[]> {\n    // Implementation would suggest prompts based on the current Docker context\n    // For example, if using PostgreSQL, suggest corresponding service templates\n    // This is a placeholder for demonstration\n    \n    const hasDatabase = context?.services?.some(s => \n      s.type === 'database' || \n      s.image?.includes('postgres') || \n      s.image?.includes('mysql') || \n      s.image?.includes('mongo'));\n    \n    const hasMCP = context?.services?.some(s => \n      s.name.includes('mcp') || \n      s.type === 'mcp');\n    \n    return [\n      {\n        id: 'docker-containerization-guide',\n        name: 'Docker Containerization Guide',\n        relevance: 100,\n        compatibleWith: ['docker-compose-database-service', 'docker-compose-mcp-service'],\n        reason: 'Provides the Docker containerization foundation'\n      },\n      {\n        id: 'docker-compose-database-service',\n        name: 'Docker Compose Database Service',\n        relevance: hasDatabase ? 100 : 70,\n        compatibleWith: ['docker-containerization-guide', 'docker-compose-mcp-service'],\n        reason: hasDatabase ? 'Required for database services in your composition' : 'Optional database service configuration'\n      },\n      {\n        id: 'docker-compose-mcp-service',\n        name: 'Docker Compose MCP Service',\n        relevance: hasMCP ? 100 : 50,\n        compatibleWith: ['docker-containerization-guide', 'docker-compose.postgres'],\n        reason: hasMCP ? 'Required for MCP services in your composition' : 'Optional MCP service configuration'\n      },\n      {\n        id: 'docker-compose-networking',\n        name: 'Docker Compose Networking',\n        relevance: 80,\n        compatibleWith: ['docker-containerization-guide'],\n        reason: 'Advanced networking configuration for your services'\n      },\n      {\n        id: 'docker-compose-deployment',\n        name: 'Docker Compose Deployment',\n        relevance: context?.environment === 'production' ? 100 : 70,\n        compatibleWith: ['docker-containerization-guide'],\n        reason: 'Deployment strategies for your Docker Compose applications'\n      }\n    ];\n  }\n  \n  /**\n   * Validates if the prompts can be combined for Docker Compose configurations\n   * @param promptIds Array of prompt IDs to validate\n   * @returns Validation result with any issues specific to Docker Compose\n   */\n  async validateCombination(promptIds: string[]): Promise<CombinationValidationResult> {\n    // Implementation would validate that the prompts make sense for Docker Compose\n    // For example, ensuring there are no conflicting service definitions\n    // This is a placeholder for demonstration\n    \n    const prompts = await Promise.all(promptIds.map(id => this.promptService.getPrompt(id)));\n    \n    // Check for Docker container prompt\n    const hasContainer = prompts.some(p => p.tags?.includes('docker') || p.tags?.includes('containerization'));\n    if (!hasContainer) {\n      return {\n        isValid: false,\n        issues: [{\n          promptId: '',\n          issue: 'Missing Docker containerization prompt',\n          severity: 'error',\n          suggestion: 'Add a Docker containerization prompt, such as docker-containerization-guide'\n        }],\n        suggestions: [{\n          promptIds: [...promptIds, 'docker-containerization-guide'],\n          reason: 'Docker containerization is required for Docker Compose configurations'\n        }]\n      };\n    }\n    \n    // In a real implementation, would do more validation specific to Docker Compose\n    \n    return {\n      isValid: true\n    };\n  }\n  \n  /**\n   * Creates a saved Docker Compose workflow\n   * @param name Name for the new workflow\n   * @param promptIds Component prompt IDs\n   * @param config Configuration for the combination\n   * @returns The created Docker Compose workflow\n   */\n  async saveWorkflow(name: string, promptIds: string[], config: WorkflowConfig): Promise<SavedWorkflow> {\n    // Implementation would save a Docker Compose workflow\n    // This is a placeholder for demonstration\n    \n    return {\n      id: `docker-compose-workflow-${Date.now()}`,\n      name,\n      promptIds,\n      config,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      version: 1,\n      category: 'docker-compose',\n      tags: ['docker', 'compose', 'deployment']\n    };\n  }\n  \n  /**\n   * Loads a previously saved Docker Compose workflow\n   * @param workflowId ID of the saved workflow\n   * @returns The loaded Docker Compose workflow\n   */\n  async loadWorkflow(workflowId: string): Promise<SavedWorkflow> {\n    // Implementation would load a Docker Compose workflow\n    // This is a placeholder for demonstration\n    \n    throw new Error(`Workflow ${workflowId} not found or not implemented yet`);\n  }\n}\n\n/**\n * Usage Examples\n * \n * ```typescript\n * // Creating a combiner\n * const promptService = new PromptService(storageAdapter);\n * const dockerCombiner = new DockerComposePromptCombiner(promptService);\n * \n * // Getting prompt suggestions for Docker Compose\n * const suggestions = await dockerCombiner.getPromptSuggestions('services', {\n *   environment: 'production',\n *   services: [\n *     {\n *       name: 'web',\n *       type: 'frontend',\n *       image: 'nginx:alpine',\n *       ports: ['80:80']\n *     },\n *     {\n *       name: 'api',\n *       type: 'backend',\n *       image: 'node:14-alpine',\n *       ports: ['3000:3000'],\n *       dependencies: ['db']\n *     },\n *     {\n *       name: 'db',\n *       type: 'database',\n *       image: 'postgres:13',\n *       volumes: ['postgres-data:/var/lib/postgresql/data']\n *     }\n *   ],\n *   composeVersion: '3.8'\n * });\n * \n * // Combining prompts for Docker Compose\n * const result = await dockerCombiner.combinePrompts([\n *   'docker-containerization-guide',\n *   'docker-compose-database-service'\n * ], {\n *   variables: {\n *     project_name: 'My Awesome Project',\n *     service_name: 'api'\n *   },\n *   environment: 'production',\n *   services: [\n *     {\n *       name: 'web',\n *       type: 'frontend',\n *       image: 'nginx:alpine',\n *       ports: ['80:80']\n *     },\n *     {\n *       name: 'api',\n *       type: 'backend',\n *       image: 'node:14-alpine',\n *       ports: ['3000:3000'],\n *       dependencies: ['db']\n *     },\n *     {\n *       name: 'db',\n *       type: 'database',\n *       image: 'postgres:13',\n *       volumes: ['postgres-data:/var/lib/postgresql/data']\n *     }\n *   ],\n *   composeVersion: '3.8'\n * });\n * \n * // Using the specialized result properties\n * console.log(result.composeConfiguration); // Get the complete Docker Compose configuration\n * console.log(result.serviceConfigurations['db']); // Get just the database service configuration\n * console.log(result.deploymentCommands); // Get the deployment commands\n * ```\n */\n\n// ============================\n// Extension Guidelines\n// ============================\n\n/**\n * When extending DockerComposePromptCombiner, consider:\n * \n * 1. Adding support for specific service types (e.g., web, backend, database, cache)\n * 2. Enhancing the context with more Docker-specific properties\n * 3. Adding support for more complex network and volume configurations\n * 4. Implementing advanced health check configurations\n * 5. Adding support for Docker Swarm mode configurations\n * 6. {{additional_extension_guidelines}}\n */",
  "isTemplate": true,
  "variables": [
    "project_name",
    "additional_docker_context",
    "additional_docker_results",
    "additional_extension_guidelines"
  ],
  "tags": [
    "devops",
    "docker",
    "docker-compose",
    "orchestration",
    "deployment"
  ],
  "category": "devops",
  "createdAt": "2024-08-08T17:30:00.000Z",
  "updatedAt": "2024-08-08T17:30:00.000Z",
  "version": 1
} 